(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{207:function(e,t,s){"use strict";s.r(t);var r=s(0),n=Object(r.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[s("p",[e._v("todo:")]),e._v(" "),e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),s("p",[e._v("npm install -g semantic-release-cli")]),e._v(" "),s("p",[e._v("semantic-release-cli setup")]),e._v(" "),s("p",[e._v("https://github.com/501981732/ls-cache-files-ts")]),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),s("p",[e._v("集成了许多优秀的开源库：")]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),s("p",[e._v("有时候我们希望取消已经发送的请求：比如输入框搜索，每次输入都要重新请求，通常的解决方案是前端做debounce节流，延时200ms发送请求，当用户连续输入时，当间隔小于200ms不会发送请求。")]),e._v(" "),s("p",[e._v("但是当极端情况，后端接口很慢，我超过200ms去输入，在前面的请求还没有响应前，可能已经发出多个请求了，接口的相应时长不定，先发的请求比后发出的请求先相应，就会导致混乱。")]),e._v(" "),s("p",[e._v("xhr中adortAPI可以取消请求"),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort",target:"_blank",rel:"noopener noreferrer"}},[e._v("XMLHttpRequest.abort()"),s("OutboundLink")],1),e._v(",but 在axios中我们并不能接触到xhr,我们希望在XHR请求中插入一段代码，当我们在外面执行cancel的时候，能驱动这段代码执行，然后执行xhr.abort方法取消请求。")]),e._v(" "),e._m(15),e._v(" "),s("p",[e._v("axios.CancelToken是一个类，\n我们直接把它实例化的对象传给请求配置中的 cancelToken 属性，CancelToken 的构造函数参数支持传入一个 executor 方法，该方法的参数是一个取消函数 c，我们可以在 executor 方法执行的内部拿到这个取消函数 c，赋值给我们外部定义的 cancel 变量，之后我们可以通过调用这个 cancel 方法来取消请求。")]),e._v(" "),s("p",[e._v("#异步分离的")]),e._v(" "),e._m(16),s("p",[e._v("我们给 axios 添加一个 CancelToken 的对象，它有一个 source 方法可以返回一个 source 对象，source.token 是在每次请求的时候传给配置对象中的 cancelToken 属性，然后在请求发出去之后，我们可以通过 source.cancel 方法取消请求。")]),e._v(" "),e._m(17),e._v(" "),e._m(18),e._m(19)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("个人博客")]),this._v(" "),t("li",[this._v("性能优化--性能优化易-如何判断性能出现的原因难")]),this._v(" "),t("li",[this._v("游戏组件库")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h4",{attrs:{id:"掌握造轮子过程-单元测试-前端工具的辅助开发-提成段位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#掌握造轮子过程-单元测试-前端工具的辅助开发-提成段位","aria-hidden":"true"}},[this._v("#")]),this._v(" 掌握造轮子过程--- 单元测试 ----前端工具的辅助开发----   提成段位")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"axios-ts版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios-ts版本","aria-hidden":"true"}},[this._v("#")]),this._v(" axios ts版本")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("ts开发项目")]),this._v(" "),t("li",[this._v("学会造轮子 单元测试")]),this._v(" "),t("li",[this._v("使用先进的开发工具")]),this._v(" "),t("li",[this._v("axios实现原理")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ol",[s("li",[e._v("jest")]),e._v(" "),s("li",[e._v("tslint")]),e._v(" "),s("li",[e._v("commitizen")]),e._v(" "),s("li",[e._v("prettier")]),e._v(" "),s("li",[e._v("rollupJs")]),e._v(" "),s("li",[e._v("semantic release 完全自动化版本管理和软件包发布")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",{attrs:{start:"7"}},[t("li",[this._v("typescript")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"axios-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios-实现","aria-hidden":"true"}},[this._v("#")]),this._v(" axios 实现")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[s("p",[e._v("在浏览器端使用 XMLHttpRequest 对象通讯")])]),e._v(" "),s("li",[s("p",[e._v("支持 Promise API")])]),e._v(" "),s("li",[s("p",[e._v("支持请求和响应的拦截器")])]),e._v(" "),s("li",[s("p",[e._v("支持请求数据和响应数据的转换")])]),e._v(" "),s("li",[s("p",[e._v("支持请求的取消")])]),e._v(" "),s("li",[s("p",[e._v("JSON 数据的自动转换\n客户端防止 XSRF")]),e._v(" "),s("p",[e._v("工具：TypeScript library starter")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[e._v("使用 "),s("strong",[e._v("RollupJS")]),e._v(" 帮助我们打包。")]),e._v(" "),s("li",[e._v("使用 "),s("strong",[e._v("Prettier")]),e._v(" 和 "),s("strong",[e._v("TSLint")]),e._v(" 帮助我们格式化代码以及保证代码风格一致性。")]),e._v(" "),s("li",[e._v("使用 "),s("strong",[e._v("TypeDoc")]),e._v(" 帮助我们自动生成文档并部署到 "),s("strong",[e._v("GitHub pages")]),e._v("。")]),e._v(" "),s("li",[e._v("使用 "),s("strong",[e._v("Jest")]),e._v("帮助我们做单元测试。")]),e._v(" "),s("li",[e._v("使用 "),s("strong",[e._v("Commitizen")]),e._v("帮助我们生成规范化的提交注释。")]),e._v(" "),s("li",[e._v("使用 "),s("strong",[e._v("Semantic release")]),e._v("帮助我们管理版本和发布。\n使用 "),s("strong",[e._v("husk")]),e._v(" 帮助我们更简单地使用 git hooks。")]),e._v(" "),s("li",[e._v("使用 "),s("strong",[e._v("Conventional changelog")]),e._v("帮助我们通过代码提交信息自动生成 change log。")]),e._v(" "),s("li",[e._v("Automatic types (*.d.ts) file generation")]),e._v(" "),s("li",[e._v("Travis integration and Coveralls report")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"错误信息增强-扩展error类-axioserror-extends-error"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#错误信息增强-扩展error类-axioserror-extends-error","aria-hidden":"true"}},[this._v("#")]),this._v(" 错误信息增强 扩展Error类 AxiosError extends Error")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ts-axios-接口扩展【工厂模式的合理运用，设计思想的转变】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts-axios-接口扩展【工厂模式的合理运用，设计思想的转变】","aria-hidden":"true"}},[this._v("#")]),this._v(" ts-axios 接口扩展【工厂模式的合理运用，设计思想的转变】")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ts-axios-拦截器实现【巧妙运用-promise-链式调用】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts-axios-拦截器实现【巧妙运用-promise-链式调用】","aria-hidden":"true"}},[this._v("#")]),this._v(" ts-axios 拦截器实现【巧妙运用 Promise 链式调用】")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ts-axios-配置化实现【巧妙运用策略模式实现配置合并】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts-axios-配置化实现【巧妙运用策略模式实现配置合并】","aria-hidden":"true"}},[this._v("#")]),this._v(" ts-axios 配置化实现【巧妙运用策略模式实现配置合并】")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ts-axios-取消功能实现【巧妙运用-promise-实现异步分离】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts-axios-取消功能实现【巧妙运用-promise-实现异步分离】","aria-hidden":"true"}},[this._v("#")]),this._v(" ts-axios 取消功能实现【巧妙运用 Promise 实现异步分离】")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"需求分析："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需求分析：","aria-hidden":"true"}},[this._v("#")]),this._v(" 需求分析：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("调用方式一")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new CancelToken(function executor(c) {\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel();\n\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("利用Primise实现异步分离")]),this._v("，在cancelToken中保存一个pending状态的Promise对象，当我们执行cancel的时候能访问到Promise，reslove，这样我们在异步请求的代码中插入这样的代码，在then函数中实现取消的请求逻辑")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("\x3c!--cancelToken是我们请求传入的cancelToken参数：new CancelToken(executor),实例化的时候传入一个executor的函数类型参数，改方法的参数是一个取消函数，我们可以在executor方法执行的内部拿到这个函数，赋值给外面的变量cancel，当我们执行cancel的时候，执行promise的reslove引用，会使promise变成reslove状态，使我们插入的这段代码执行then方法--\x3e\nif (cancelToken) {\n  cancelToken.promise\n    .then(reason => {\n      request.abort()\n      reject(reason)\n    })\n}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("CancelToken类的实现\nexport default class CancelToken {\n  promise: Promise<string>\n  reason?: string\n\n  constructor(executor: CancelExecutor) {\n    let resolvePromise: ResolvePromise\n    this.promise = new Promise<string>(resolve => {\n      resolvePromise = resolve\n    })\n\n    executor(message => {\n      if (this.reason) {\n        return\n      }\n      this.reason = message\n      resolvePromise(this.reason)\n    })\n  }\n}\n\n")])])])}],!1,null,null,null);n.options.__file="从0写个axios use typescript.md";t.default=n.exports}}]);