(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{254:function(n,e,t){"use strict";t.r(e);var s=t(0),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"面向切面编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向切面编程","aria-hidden":"true"}},[n._v("#")]),n._v(" 面向切面编程")]),n._v(" "),t("hr"),n._v(" "),t("blockquote",[t("p",[n._v("面向切面编程Aspect Oriented Programming（AOP）,主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中的各部分之间低耦合性的隔离效果。")])]),n._v(" "),t("blockquote",[t("p",[n._v("对程序做无侵入干扰  将来对某些功能进行热插拔 不会影响其他 例如埋点 或者测某些功能性能")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 原始方法 很恶心 每个函数里面去写\n// 测函数执行时间\nfunction test() {\n    let startTime = new Date().getTime()\n    \x3c!--函数功能--\x3e\n    console.log('do something')\n    return 'test'\n    let endTime = new Date().getTime()\n    console.log(endTime - startTime)\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// step1:\nFunction.prototype.before = function(fn) {\n    let self = this\n    fn()\n    self.apply(this,arguments)\n}\n\nFunction.prototype.after = function(fn) {\n    let self = this\n    self.apply(this,arguments)\n    fn()\n}\n\ntest.before(function(){\n    console.log('before')\n})\ntest.after(function(){\n    console.log('after')\n})\n问题: 函数执行了2次\ntest作为中转 暂时先不执行 \nbefore 和before的回调送到 after里面去\nafter 和 after的回调送到before去\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// step2:\n改进：\n\x3c!--顺序：挂在 self -> test 执行before的回调 执行self  执行after的回调 --\x3e\n\x3c!--执行before 不会执行self 而是挂载不执行 --\x3e\nFunction.prototype.before = function(fn) {\n    let self = this\n    return function() {\n        \x3c!--this指向 ~~~~ windows--\x3e\n        \x3c!--self指向 function实例 test --\x3e\n        fn.apply(this,arguments) // 为后期改写this\n        self.apply(self,arguments)\n    }\n}\n\nFunction.prototype.after = function(fn) {\n    let self = this\n    return function() {\n        // after 先执行本身this 再执行回调\n        // 这里的self 其实是before执行后返回的函数 先执行这个 再执行回调\n        self.apply(self,arguments)\n        fn.apply(this,arguments)\n    }\n}\n\ntest.before(function(){\n    console.log('before')\n}).after(function(){\n    console.log('after')\n})()\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// step3:\n改进：\n // 1.加上更加复杂的验证 假如before 返回false 不再执行\n // 2. 拿到函数本身的返回值\nFunction.prototype.before = function(fn) {\n    let self = this\n    return function() {\n        if (fn.apply(this,arguments) == false) {\n            return false\n        }\n        return self.apply(self,arguments)\n    }\n}\n\nFunction.prototype.after = function(fn) {\n    let self = this\n    return function() {\n        var result =  self.apply(self,arguments)\n        if (result == false) {\n            return false\n        }\n        fn.apply(this,arguments)\n        return result\n    }\n}\n\ntest.before(function(){\n    console.log('before')\n    return false // 假如before回调返回false,则不再执行 \n}).after(function(){\n    console.log('after')\n})()\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const timeTaken = callback => {\nconsole.time('timeTaken');  const r = callback();\nconsole.timeEnd('timeTaken');  return r;\n};\n")])])])])}],!1,null,null,null);a.options.__file="AOP面向切面编程.md";e.default=a.exports}}]);