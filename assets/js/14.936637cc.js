(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{261:function(t,e,n){"use strict";n.r(e);var r=n(0),a=Object(r.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[t._m(0),t._v(" "),n("p",[t._v("以前在csdn segmentfault 掘金 有道 github都有零散的笔记或博客,但是太乱啦，还是自己搭一个整理下比较好")]),t._v(" "),t._m(1),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("冴羽博客"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/yygmind/blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("木易杨说"),n("OutboundLink")],1),t._v(" "),n("a",{attrs:{href:"https://juejin.im/user/56dea4aa7664bf00559f002d/posts",target:"_blank",rel:"noopener noreferrer"}},[t._v("博客"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/xitu/gold-miner",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金翻译计划"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/webproblem/learning-article",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端导航"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/wxyyxc1992/Web-Series",target:"_blank",rel:"noopener noreferrer"}},[t._v("wxyyxc1992/Web-Series"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/easonyq/easonyq.github.io",target:"_blank",rel:"noopener noreferrer"}},[t._v("cache github"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/berwin/Blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("中专逆袭blog"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/user/5b2cc5fee51d4553156be12f",target:"_blank",rel:"noopener noreferrer"}},[t._v("算法"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/muwoo/blogs",target:"_blank",rel:"noopener noreferrer"}},[t._v("又一个blog"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/hanzichi/underscore-analysis",target:"_blank",rel:"noopener noreferrer"}},[t._v("underscore-analysis"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes",target:"_blank",rel:"noopener noreferrer"}},[t._v("吴恩达老师的机器学习课程个人笔记\n"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("###vue源码解析")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/opendigg/awesome-github-vue",target:"_blank",rel:"noopener noreferrer"}},[t._v("开源项目总结库"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank",rel:"noopener noreferrer"}},[t._v("awesome-vue"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/ustbhuangyi/vue-analysis",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue源码分析 2288"),n("OutboundLink")],1),t._v(" 推荐")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/answershuto/learnVue",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue.js源码解析 5207 掘金"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/HcySunYang/vue-design",target:"_blank",rel:"noopener noreferrer"}},[t._v("逐行阅读vue源码 3150 不维护"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/Ma63d/vue-analysis",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 源码注释版 及 Vue 源码详细解析 643 不维护"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("###node学习")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/ElemeFE/node-interview",target:"_blank",rel:"noopener noreferrer"}},[t._v("ele node面试 7705 "),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/chenshenhai/koa2-note",target:"_blank",rel:"noopener noreferrer"}},[t._v("koa2进阶学习笔记 2625"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/yjhjstz/deep-into-node",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解Node.js：核心思想与源码分析 2230"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/chyingp/nodejs-learning-guide",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node学习笔记 4239"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("###webpack学习\n"),n("a",{attrs:{href:"https://webpack.docschina.org/guides/author-libraries",target:"_blank",rel:"noopener noreferrer"}},[t._v("中文文档"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"http://webpack.wuhaolin.cn/",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入浅出"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("【进阶 1 期】 调用堆栈")]),t._v(" "),n("p",[t._v("【进阶 2 期】 作用域闭包")]),t._v(" "),n("p",[t._v("【进阶 3 期】 this 全面解析")]),t._v(" "),n("p",[t._v("【进阶 4 期】 深浅拷贝原理")]),t._v(" "),n("p",[t._v("【进阶 5 期】 原型 Prototype")]),t._v(" "),n("p",[t._v("【进阶 6 期】 高阶函数")]),t._v(" "),n("p",[t._v("【进阶 7 期】 事件机制")]),t._v(" "),n("p",[t._v("【进阶 8 期】 Event Loop 原理")]),t._v(" "),n("p",[t._v("【进阶 9 期】 Promise 原理")]),t._v(" "),n("p",[t._v("【进阶 10 期】Async/Await 原理")]),t._v(" "),n("p",[t._v("【进阶 11 期】防抖/节流原理")]),t._v(" "),n("p",[t._v("【进阶 12 期】模块化详解")]),t._v(" "),n("p",[t._v("【进阶 13 期】ES6 重难点")]),t._v(" "),n("p",[t._v("【进阶 14 期】计算机网络概述")]),t._v(" "),n("p",[t._v("【进阶 15 期】浏览器渲染原理")]),t._v(" "),n("p",[t._v("【进阶 16 期】webpack 配置")]),t._v(" "),n("p",[t._v("【进阶 17 期】webpack 原理")]),t._v(" "),n("p",[t._v("【进阶 18 期】前端监控")]),t._v(" "),n("p",[t._v("【进阶 19 期】跨域和安全")]),t._v(" "),n("p",[t._v("【进阶 20 期】性能优化")]),t._v(" "),n("p",[t._v("【进阶 21 期】VirtualDom 原理")]),t._v(" "),n("p",[t._v("【进阶 22 期】Diff 算法")]),t._v(" "),n("p",[t._v("【进阶 23 期】MVVM 双向绑定")]),t._v(" "),n("p",[t._v("【进阶 24 期】Vuex 原理")]),t._v(" "),n("p",[t._v("【进阶 25 期】Redux 原理")]),t._v(" "),n("p",[t._v("【进阶 26 期】路由原理")]),t._v(" "),n("p",[t._v("【进阶 27 期】VueRouter 源码解析")]),t._v(" "),n("p",[t._v("【进阶 28 期】ReactRouter 源码解析")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("javascript-question"),n("OutboundLink")],1)]),t._v(" "),t._m(2),n("p",[t._v("普通参数都是 值 传递的，而对象则不同，是 引用 传递。所以说，birthYear是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的 复制 。（可以参考问题46）")]),t._v(" "),n("p",[t._v('变量birthYear有一个对"1997"的引用，而传入的参数也有一个对"1997"的引用，但二者的引用并不相同。当我们通过给 year赋值"1998"来更新year的值的时候我们只是更新了year（的引用）。此时birthYear仍然是"1997".')]),t._v(" "),n("p",[t._v('而person是个对象。参数member引用与之 相同的 对象。当我们修改member所引用对象的属性时,person的相应属性也被修改了,因为他们引用了相同的对象. person的 name属性也变成了 "Lydia".')]),t._v(" "),t._m(3),n("p",[t._v("Error")]),t._v(" "),t._m(4),t._v(" "),n("p",[t._v("当我们给myCounter增加一个值的时候会抛出一个异常： myCounter是只读的，不能被修改。")]),t._v(" "),t._m(5),t._m(6),t._m(7),t._v(" "),t._m(8),t._m(9),t._v(" "),t._m(10),t._m(11)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"博客"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#博客","aria-hidden":"true"}},[this._v("#")]),this._v(" 博客")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"优秀博客"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优秀博客","aria-hidden":"true"}},[this._v("#")]),this._v(" 优秀博客")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('function getInfo(member, year) {\n  member.name = "Lydia";\n  year = "1998";\n}\n\nconst person = { name: "Sarah" };\nconst birthYear = "1997";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('57\n\n// counter.js\nlet counter = 10;\nexport default counter;\n// index.js\nimport myCounter from "./counter";\n\nmyCounter += 1;\n\nconsole.log(myCounter);\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("引入的模块是 "),e("strong",[this._v("只读")]),this._v(" 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;\n\n\nrunning sum.js, running index.js, 3\n")])])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{attrs:{class:"token comment"}},[t._v("// a.js")]),t._v("\n"),n("span",{attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),n("span",{attrs:{class:"token keyword"}},[t._v("let")]),t._v(" count "),n("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{attrs:{class:"token number"}},[t._v("0")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),n("span",{attrs:{class:"token comment"}},[t._v("//输出的是值的引用，指向同一块内存")]),t._v("\n"),n("span",{attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),n("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{attrs:{class:"token function-variable function"}},[t._v("add")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token operator"}},[t._v("=>")]),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    count"),n("span",{attrs:{class:"token operator"}},[t._v("++")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),n("span",{attrs:{class:"token comment"}},[t._v("//此时引用指向的内存值发生改变")]),t._v("\n"),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{attrs:{class:"token comment"}},[t._v("// b.js")]),t._v("\n"),n("span",{attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" count"),n("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" add "),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),n("span",{attrs:{class:"token string"}},[t._v("'./a.js'")]),t._v("\n\nconsole"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("log")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("count"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token comment"}},[t._v("//0")]),t._v("\n"),n("span",{attrs:{class:"token function"}},[t._v("add")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("log")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("count"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token comment"}},[t._v("//1")]),t._v("\n\n")])])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ul",[n("li",[n("p",[n("code",[t._v("esModule")]),t._v(" import命令是"),n("strong",[t._v("编译阶段")]),t._v("执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。 使得"),n("strong",[t._v("静态分析")]),t._v("成为可能(按需引入)。")])]),t._v(" "),n("li",[n("p",[t._v("这是"),n("code",[t._v("CommonJS")]),t._v("中require（）和import之间的区别。使用require()，您可以在"),n("strong",[t._v("运行代码")]),t._v("时根据需要加载依赖项(所以必须全局引入文件)。 如果我们使用require而不是import，running index.js，running sum.js，3会被依次打印。")])]),t._v(" "),n("li",[n("p",[t._v("这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。so-----出现import()动态加载提案。返回一个 Promise 对象.")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("const path = './' + fileName;\nconst myModual = require(path);\nimport(path).then()\n")])])])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ul",[n("li",[n("code",[t._v("commentJs")]),t._v("具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝（浅拷贝）在内存中。下次加载文件时，直接从内存中取值")]),t._v(" "),n("li",[n("code",[t._v("commonJs")]),t._v("输出的是值的"),n("strong",[t._v("浅拷贝")]),t._v("，"),n("code",[t._v("esModule")]),t._v("输出"),n("strong",[t._v("值的只读引用")]),t._v(",也就是 假如我在b中引入了a的x值，再调用a的方法改变x,这时在打印x，是改变后的")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('async function getData() {\n  return await Promise.resolve("I made it!");\n}\n\nconst data = getData();\nconsole.log(data);\n\n Promise {<pending>}\n 异步函数始终返回一个promise。await仍然需要等待promise的解决：当我们调用getData()并将其赋值给data，此时data为getData方法返回的一个挂起的promise，该promise并没有解决。\n\n如果我们想要访问已解决的值"I made it!"，可以在data上使用.then()方法\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('function giveLydiaPizza() {\n  return "Here is pizza!"\n}\n\nconst giveLydiaChocolate = () => "Here\'s chocolate... now go hit the gym already."\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)\n\n箭头函数没有prototype\n')])])])}],!1,null,null,null);a.options.__file="README.md";e.default=a.exports}}]);