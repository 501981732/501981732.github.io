(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{228:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"工厂模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 工厂模式")]),e._v(" "),n("p",[e._v("工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Man {\n    constructor(name) {\n        this.name = name\n    }\n    alertName() {\n        alert(this.name)\n    }\n}\n\nclass Factory {\n    static create(name) {\n        return new Man(name)\n    }\n}\n\nFactory.create('1')\nFactory.create('2')\n")])])]),n("h2",{attrs:{id:"单例模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单例模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 单例模式")]),e._v(" "),n("p",[e._v("单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。")]),e._v(" "),n("p",[e._v("单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Singleton {\n    constructor(){\n\n    }\n    static getInstance() {\n        let instance\n        if (!instance) {\n            instance = new Singleton()\n        }\n        return instance\n    }\n}\nlet s1 = Singleton.getInstance()\nlet s2 = Singleton.getInstance()\nconsole.log(s1 === s2) // true\n")])])]),n("p",[e._v("比如vuex源码中的通过外部变量来控制只安装一次vuex")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let Vue\nexport function install(_Vue) {\n    if (Vue && _Vue === Vue) {\n        \x3c!--如果发现 Vue 有值，就不重新创建实例了  --\x3e\n        return\n    }\n    Vue = _Vue\n    applyMixin(Vue)\n}\n")])])]),n("h3",{attrs:{id:"适配器模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 适配器模式")]),e._v(" "),n("p",[e._v("适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Plug {\n    getName() {\n        return '港版插头'\n    }\n}\nclass Target {\n    constructor() {\n        this.plug = new Plug()\n    }\n    getName() {\n        return this.plug.getName() + '哈哈'\n    }\n}\n\nlet target = new Target()\ntarget.getName()\n\n")])])]),n("p",[e._v("在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 computed 来做转换这件事情，这个过程就使用到了适配器模式。")]),e._v(" "),n("h2",{attrs:{id:"装饰模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#装饰模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 装饰模式")]),e._v(" "),n("blockquote",[n("p",[e._v("装饰模式不需要改变已有的接口，作用是给对象添加功能。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function readonly(target, key, descriptor) {\n  descriptor.writable = false\n  return descriptor\n}\n\nclass Test {\n  @readonly\n  name = 'wm'\n}\n\nlet t = new Test()\nt.wm = '111' // 不可修改\n\nreact中\nimport { connect } from 'react-redux'\nclass MyComponent extends React.Component {\n    // ...\n}\nexport default connect(mapStateToProps)(MyComponent)\n\n")])])]),n("h2",{attrs:{id:"代理模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代理模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 代理模式")]),e._v(" "),n("blockquote",[n("p",[e._v("代理是为了控制对对象的访问，不让外部直接访问到对象。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<ul id=\"ul\">\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\n<script>\n    let ul = document.querySelector('#ul')\n    ul.addEventListener('click', (event) => {\n        console.log(event.target);\n    })\n<\/script>\n\n")])])]),n("h2",{attrs:{id:"发布-订阅模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 发布-订阅模式")]),e._v(" "),n("blockquote",[n("p",[e._v("发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。比如click")])]),e._v(" "),n("h2",{attrs:{id:"外观模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#外观模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 外观模式")]),e._v(" "),n("blockquote",[n("p",[e._v("外观模式提供了一个借口，隐藏了内部的逻辑，更加方便外部调用")])]),e._v(" "),n("p",[e._v("比如实现一个兼容多种浏览器的添加时间的方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function addEvent(elm, evType, fn, useCapture) {\n  if (elm.addEventListener) {\n    elm.addEventListener(evType, fn, useCapture)\n    return true\n  } else if (elm.attachEvent) {\n    var r = elm.attachEvent("on" + evType, fn)\n    return r\n  } else {\n    elm["on" + evType] = fn\n  }\n\n')])])])])}],!1,null,null,null);s.options.__file="简单介绍.md";t.default=s.exports}}]);