(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{251:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("在现今的 Web 开发中，JavaScript 几乎占据所有版面，除了控制页面逻辑与操作 DOM 对象以外，连 CSS 都直接写在 JavaScript 里面了，就算浏览器都还沒有实现的特性，总会有人做出对应的 Polyfills，让你快速的将新 Feature 应用到 Production 环境中，更別提我们还有 Babel 等工具帮忙转译。")]),t._v(" "),s("p",[t._v("而 CSS 就不同了，除了制定 CSS 标准规范所需的时间外，各家浏览器的版本、实战进度差异更是旷日持久，再加上 CSS 并非 Javascript 这样的动态语言，我们无法简单的提供 Polyfills，顶多利用 PostCSS、Sass 等工具來帮我們转译出浏览器能接受的 CSS，而剩下的就是浏览器的事了。")]),t._v(" "),s("p",[t._v("而就现阶段的 Web 技术來看，开发者们能操作的就是通过 JS 去控制 DOM 与 CSSOM，來来影响页面的变化，但是对于接下來的 Layout、Paint 与 Composite 就几乎沒有控制权了。")]),t._v(" "),s("p",[t._v("既无法让各家浏览器快速并统一实战规格，亦不能轻易产生 Polyfills，所以到现在我们依然无法大胆使用 Flexbox，即便它早在 2009 年就被提出了…")]),t._v(" "),s("p",[t._v("但 CSS 并非就此驻足不前。")]),t._v(" "),s("p",[t._v("为了解決上述问题，为了让 CSS 的魔力不再浏览器把持，Houdini 就诞生了！")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.w3cplus.com/css/css-houdini.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("houdiniAPI介绍"),s("OutboundLink")],1)]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._m(5),t._v(" "),t._m(6),t._v(" "),s("p",[t._v("( registerLayout 和 registerPaint)已经了解过了，估计现在你想知 道的是，这些代码得放在哪里呢?答案就是 worklet 脚本(工作流脚本 文件)。\nWorklets 的概念和 web worker 类似，它们允许你引入脚本文件并执 行特定的 JS 代码，这样的 JS 代码要满足两个条件:第一，可以在渲染 流程中调用;第二，和主线程独立。\nWorklet 脚本严格控制了开发者所能执行的操作类型，这就保证了性能 Worklets 的特点就是轻量以及生命周期较短。")]),t._v(" "),t._m(7),t._m(8),t._v(" "),t._m(9),s("p",[t._v("来注册下~")]),t._v(" "),t._m(10),t._m(11)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"css-houdini"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-houdini","aria-hidden":"true"}},[this._v("#")]),this._v(" css houdini")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("parser paint layoutAPI")]),this._v(" "),e("li",[this._v("Worklets")]),this._v(" "),e("li",[this._v("Properties/Values")]),this._v(" "),e("li",[this._v("Typed OM Object")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api","aria-hidden":"true"}},[this._v("#")]),this._v(" API")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("CSS Properties and Values API")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("const textBox = document.querySelector('.textBox'); \n// GET \nconst Bxshc = getComputedStyletextBox).getPropertyValue('--box-shadow-color'); \n// SET \ntextBox.style.setProperty('--box-shadow-color', 'new color');\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("CSS Parser API 基本思想会变:允许开发者⾃自由扩展 CSS 词法分析器器，引⼊入新的结构(constructs)， ⽐比如新的媒体规则、新的伪类嵌套、@extends、 @apply 等等。\n只要新的词法分析器器知道如何 解析这些新结构，CSSOM 就 不不会直接忽略略它们，⽽而是把这 些结构放到正确的地⽅")])]),this._v(" "),e("li",[e("p",[this._v("CSS Layout API允许开发 者可以通过 CSS Layout API 实现⾃自⼰己的布局模块 (layout module)，这⾥里里 的“布局模块”指的是 display 的属性值。也就是 说，这个 API 实现以后， 开发者⾸首次拥有了了像 CSS 原⽣生代码(比如 display:flex、 display:table)那样的布 局能⼒力力。")])]),this._v(" "),e("li",[e("p",[this._v("CSS Painting API 与Layout类似，提供了一个 registerPaint方法。")])]),this._v(" "),e("li",[e("p",[this._v("Typed OM Object 解决⽬目前模型的⼀一些问题，并实现 CSS Parsing API 和 CSS 属性与值 API 相关的特性。最主要的功能在于将 CSSOM 所使用的字串值转换成具有型別意义的 JavaScript 表示形态。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"worklet"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#worklet","aria-hidden":"true"}},[this._v("#")]),this._v(" worklet")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("CSS.paintWorklet.addModule('xxx.js')\n\nCSS.layoutWorklet.addModule(‘xxx.js')\n\nregisterPaint('simpleRect', XXClass);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"css变量-在动画中不生效？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css变量-在动画中不生效？","aria-hidden":"true"}},[this._v("#")]),this._v(" css变量 在动画中不生效？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v(".btn {\n    --startColor: gray;\n    background: linear-gradient(var(startColor),yellow)\n    transition: --startColor 1s\n}\n.btn:hover {\n    --startColor: green;\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("if (window.CSS) {\n    CSS.registerProperty({\n        name: '--startColor',\n        syntax: '<color>',\n        inherits: false,\n        initialValue: 'transparent'\n    });\n}\n//注销\n    CSS.registerProperty({--startColor})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Typed OM Object \nel.attributeStyleMap.set('padding', CSS.px(42))\nconst padding = el.attributeStyleMap.get('padding')\nconsole.log(padding.value, padding.unit)\n")])])])}],!1,null,null,null);r.options.__file="csshoudini.md";e.default=r.exports}}]);