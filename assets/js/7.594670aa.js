(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{258:function(t,e,_){"use strict";_.r(e);var r=_(0),i=Object(r.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),_("p",[t._v("TCP/IP协议族按层次：")]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),_("p",[t._v("TCP")]),t._v(" "),t._m(6),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),_("p",[t._v("内容协商技术分为三类：")]),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._v(" "),t._m(50),t._v(" "),t._m(51),t._v(" "),t._m(52),t._v(" "),t._m(53),t._v(" "),t._m(54),t._v(" "),t._m(55),t._v(" "),t._m(56),t._v(" "),_("p",[t._v("HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。")]),t._v(" "),_("p",[t._v("TLS 中使用了两种加密技术,对称加密和非对称加密")]),t._v(" "),t._m(57),t._v(" "),t._m(58),t._v(" "),t._m(59),t._v(" "),t._m(60),t._v(" "),_("p",[t._v("流程：")]),t._v(" "),_("p",[t._v("首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了")]),t._v(" "),t._m(61),t._v(" "),_("p",[t._v("HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。")]),t._v(" "),_("p",[t._v("在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。")]),t._v(" "),t._m(62),t._v(" "),t._m(63),t._v(" "),_("p",[t._v("在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。")]),t._v(" "),_("p",[t._v("帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。")]),t._v(" "),_("p",[t._v("多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。")]),t._v(" "),t._m(64),t._v(" "),_("p",[t._v("http1是以文本的方式传输数据，http2引入了新的编码机制，所有传输的数据都被分割，并采用二进制格式编码")]),t._v(" "),t._m(65),t._v(" "),_("p",[t._v("在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值")]),t._v(" "),t._m(66),t._v(" "),t._m(67),t._v(" "),_("p",[t._v("某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。")]),t._v(" "),t._m(68),t._v(" "),t._m(69),t._v(" "),t._m(70),t._v(" "),_("p",[t._v("当出现丢包，真个TCP都要开始等待重传，就导致后面的数据都被阻塞，但是多余HTTP1来说，可以开启多个TCP链接，一个连接不会影响其他。")]),t._v(" "),t._m(71),t._v(" "),t._m(72),t._v(" "),t._m(73),t._v(" "),t._m(74),t._v(" "),_("p",[t._v("虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题")]),t._v(" "),t._m(75),t._v(" "),t._m(76),t._v(" "),_("p",[t._v("通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。")]),t._v(" "),t._m(77),t._v(" "),_("p",[t._v("假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。")]),t._v(" "),_("p",[t._v("当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。")]),t._v(" "),_("p",[t._v("当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。")]),t._v(" "),t._m(78),t._v(" "),_("p",[_("a",{attrs:{href:"https://github.com/skyline75489/what-happens-when-zh_CN",target:"_blank",rel:"noopener noreferrer"}},[t._v("what-happens-when"),_("OutboundLink")],1)]),t._v(" "),t._m(79),t._v(" "),_("p",[t._v("因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么")]),t._v(" "),t._m(80)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"http入门到放弃"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http入门到放弃","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP入门到放弃")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_1-网络基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-网络基础","aria-hidden":"true"}},[this._v("#")]),this._v(" 1.网络基础")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("应用层 http协议 DNS..")]),this._v(" "),e("li",[this._v("传输层 TCP传输控制协议 UDP用户数据报协议...")]),this._v(" "),e("li",[this._v("网络层 IP协议...")]),this._v(" "),e("li",[this._v("链路层")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("chrome一次性只能处理6个tcp请求。其他的请求必须等待6个请求完成，这个等待时间是构成stalling的主要部分")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("与http协议关系密切的协议: IP,TCP,DNS")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 负责传输的IP协议： 把各种数据包传递给对方，两个最重要的条件是IP地址和MAC地址      ARP解析地址的协议\n- 确保可靠性的TCP协议： 采用三次握手的策略 利用两个TCP标志，SYN（synchronize）和ACK（acknowledgement）\n- 负责域名解析的DNS服务： 提供域名到IP地址之间的解析服务\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("sequenceDiagram\n发送端->>接收端: 标有SYN的数据包发送给你了\n接收端->>发送端:收到！并发送标有SYN/ACK的数据包\n发送端->接收端: 明白！发送标有ACK的数据包\n\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("三者在http协议通讯过程中发挥的作用")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("发送端从上往下走，接收端从下往上走\n\n客户端：访问www.baidu.com/xss/web.html \n经过DNS协议：返回对应的IP地址\nHTTP协议的职责：生成对应的http请求报文 （请给我www.baidu.com/xss/web.html 页面的资源）\nTCP协议的职责：将HTTP请求报文分割成报文段把每个报文段（打上标记序号和端口号）可靠地传给对方\nIP协议：搜索对方的地址，一遍中转一遍传送\n\n--发送端在层与层之间传递数据时，每经过一层就会打上该层的首部信息，\n--反之，接受端在层与层之间传递数据时，每经过一层就会把对应的首部消去\n\n服务器端：\nTCP协议的职责：从对方那里接受报文段，按序号以原来的顺序重组\nHTTP协议的职责：对Web服务器请求内容的处理 (原来是想要这台计算机上xss/资源呀)\n请求的结果也同样利用TCP/IP通讯协议向用户回传\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_2-简单的http协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-简单的http协议","aria-hidden":"true"}},[this._v("#")]),this._v(" 2.简单的HTTP协议")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("HTTP协议用于客户端和服务端之间的通讯")]),t._v(" "),_("li",[t._v("通过请求和响应的交换达成通讯\n"),_("ul",[_("li",[t._v("请求报文是由请求方法，请求URI，协议版本号，可选的请求头部字段和内容实体构成")]),t._v(" "),_("li",[t._v("响应报文是由协议版本，状态码，用以解释状态码的原因短语，可选的响应首部字段，以及实体")])])]),t._v(" "),_("li",[t._v("HTTP不保存状态的协议 无状态（stateless）协议")]),t._v(" "),_("li",[t._v("告知服务器意图的HTTP请求\n"),_("ol",[_("li",[_("p",[t._v("GET 获取资源")]),t._v(" "),_("pre",[_("code",[t._v(" GET方法用来请求访问已被URI识别的资源。指定的资源京服务器解析后返回响应的内容\n")])])]),t._v(" "),_("li",[_("p",[t._v("POST 传输实体主体\npost主要目的并不是获取响应的主体内容，而是 ‘我要把信息告诉你’")])]),t._v(" "),_("li",[_("p",[t._v("PUT 传输文件")])]),t._v(" "),_("li",[_("p",[t._v("HEAD 获取报文首部")])]),t._v(" "),_("li",[_("p",[t._v("DELETE 删除文件")])]),t._v(" "),_("li",[_("p",[t._v("OPTIONS 询问支持的方法  ‘你支持什么方法？’")])]),t._v(" "),_("li",[_("p",[t._v("TRACE 追踪路径")])]),t._v(" "),_("li",[_("p",[t._v("CONNECT 要求用隧道协议连接代理")])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"持久连接-connection-keep-alive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持久连接-connection-keep-alive","aria-hidden":"true"}},[this._v("#")]),this._v(" 持久连接 Connection:keep-alive")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("    持久连接的特点：只要任意一端没有明确提出断开连接，就保持TCP连接状态，减少了TCP连接建立和断开造成的额外开销，减轻服务器负担\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"管道化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#管道化","aria-hidden":"true"}},[this._v("#")]),this._v(" 管道化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("    同时并行发送多个请求  \n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"cookie技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie技术","aria-hidden":"true"}},[this._v("#")]),this._v(" cookie技术")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("Cookie技术通过在请求和响应报文中加入Cookie信息来控制服务端状态\n\nCookie会根据从服务器端发送的响应报文中的Set-Cookie的首部字段信息，通知客服端保存Cookie，当下次服务端再往该服务器发送请求时会自动在请求报文中加入cookie字段\n服务器端发现客户端发送过来的cookie回去检查是哪个客户端发来的请求，然后对比服务器上的记录，最后得到之前的状态\n\n\n第一次没有cookie信息下的请求：\n    \n    客户端发送请求，服务端生成Cookie记住是谁发送的，然后偶在响应首部信息中加Set-Cookie返回，客户端保存Cookie\n    \n第二次之后（存有cookie）的请求\n\n    客户端请求 在首部信息中自动添加cookie 服务端检查cookie，再响应\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_3-http报文中的http信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-http报文中的http信息","aria-hidden":"true"}},[this._v("#")]),this._v(" 3.http报文中的http信息")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("本章了解请求和响应是如何运作的")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("用于HTTP协议交互的信息被成为HTTP报文，分为报文首部，报文主体\n")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("请求报文\n"),_("ol",[_("li",[t._v("报文首部\n"),_("ul",[_("li",[t._v("请求行  (请求的方法，请求URI HTTP版本)")]),t._v(" "),_("li",[t._v("请求首部字段")]),t._v(" "),_("li",[t._v("通用首部字段")]),t._v(" "),_("li",[t._v("实体首部字段")])])]),t._v(" "),_("li",[t._v("空行（CR+LF）")]),t._v(" "),_("li",[t._v("报文主体")])])]),t._v(" "),_("li",[t._v("响应报文\n"),_("ol",[_("li",[t._v("报文首部\n"),_("ul",[_("li",[t._v("状态行  （状态码，原因短语  HTTP版本）")]),t._v(" "),_("li",[t._v("响应首部字段")]),t._v(" "),_("li",[t._v("通用首部字段")]),t._v(" "),_("li",[t._v("实体首部字段")])])]),t._v(" "),_("li",[t._v("空行（CR+LF）")]),t._v(" "),_("li",[t._v("报文主体")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("首部字段中包含请求响应的各种条件和属性的各类首部")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"编码提成传输速率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码提成传输速率","aria-hidden":"true"}},[this._v("#")]),this._v(" 编码提成传输速率")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("压缩传输的内容编码，分类：\n"),_("ul",[_("li",[t._v("gzip （GUN zip）")]),t._v(" "),_("li",[t._v("compress （UNIX系统的标准压缩）")]),t._v(" "),_("li",[t._v("deflate （zlib）")]),t._v(" "),_("li",[t._v("identity （不压缩）")])])]),t._v(" "),_("li",[t._v("分块发送的分块传输编码 --把实体主体分块")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"发送多种数据的多部分对象集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送多种数据的多部分对象集合","aria-hidden":"true"}},[this._v("#")]),this._v(" 发送多种数据的多部分对象集合")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("通常在文件上传是使用")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("multipart/form-data 文件上传时使用")]),this._v(" "),e("li",[this._v("multipart/buteranges 响应206（部分内容）包含了多个范围的内容时使用")]),this._v(" "),e("li",[this._v("content-Type: multipart/form-data ;"),e("strong",[this._v("boundary")]),this._v("=xxxx    使用boundary花纹多部分对象集合指明的各类实体")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"获取部分内容的范围请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取部分内容的范围请求","aria-hidden":"true"}},[this._v("#")]),this._v(" 获取部分内容的范围请求")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("从5001到10000字节Range: bytes=5001-10000，xxxx-xxxx")]),this._v(" "),e("li",[this._v("从5001到最后字节Range: bytes=5001-")]),this._v(" "),e("li",[this._v("针对范围请求，会响应206 另外对于多重范围的范围请求,会在响应首部加上mutipart/buyeranges")]),this._v(" "),e("li",[this._v("若服务器无法响应范围请求，则返回200以及完整实体内容")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"内容协商返回最合适的内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内容协商返回最合适的内容","aria-hidden":"true"}},[this._v("#")]),this._v(" 内容协商返回最合适的内容")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最合适的资源。\n一般包括 语言，字符集，编码方式为基准判断响应的资源")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("Accept")]),t._v(" "),_("li",[t._v("Accept-Charset")]),t._v(" "),_("li",[t._v("Accept- Encoding")]),t._v(" "),_("li",[t._v("Accept-Language")]),t._v(" "),_("li",[t._v("Content-Language")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 服务器驱动协商\n- 客户端驱动协商\n- 透明协商\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_4-常见http状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-常见http状态码","aria-hidden":"true"}},[this._v("#")]),this._v(" 4.常见HTTP状态码")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("本章介绍HTTP状态码")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("状态码的职责是当客户端向服务端发送请求时，描述返回的请求。\n")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("table",[_("thead",[_("tr",[_("th",[t._v("header 1")]),t._v(" "),_("th",[t._v("类别")]),t._v(" "),_("th",[t._v("原因短语")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1XX")]),t._v(" "),_("td",[t._v("Informational(信息性状态码)")]),t._v(" "),_("td",[t._v("接受的请求正在处理")])]),t._v(" "),_("tr",[_("td",[t._v("2XX")]),t._v(" "),_("td",[t._v("Success(成功状态码)")]),t._v(" "),_("td",[t._v("请求正确处理完毕")])]),t._v(" "),_("tr",[_("td",[t._v("3XX")]),t._v(" "),_("td",[t._v("Redirection(重定向)")]),t._v(" "),_("td",[t._v("需要进行附加操作以完成请求")])]),t._v(" "),_("tr",[_("td",[t._v("4XX")]),t._v(" "),_("td",[t._v("Client Error(客户端错误状态码)")]),t._v(" "),_("td",[t._v("服务器无法处理请求")])]),t._v(" "),_("tr",[_("td",[t._v("5XX")]),t._v(" "),_("td",[t._v("Server Error(服务端错误状态码)")]),t._v(" "),_("td",[t._v("服务端处理请求出错")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_2xx-成功"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-成功","aria-hidden":"true"}},[this._v("#")]),this._v(" 2xx 成功")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("2xx的响应结果表明请求被正确处理了")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("strong",[t._v("200 OK")]),_("br"),t._v("\n客户端发来的请求被正确处理了")]),t._v(" "),_("li",[_("strong",[t._v("204 No Content")]),_("br"),t._v("\n请求被正确处理了，但是没有资源可返回。"),_("em",[t._v("(一般只需要从客户端往服务器发送信息，二队客户端不需要发送新信息内容的情况下使用。)")])]),t._v(" "),_("li",[t._v("206 Partial Content (对资源某一部分的请求)"),_("br"),t._v("\n表明客户端进行了范围请求，而服务器成功执行了这部分的GET请求，请求不成功则会返回200请求全部")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_3xx-重定向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-重定向","aria-hidden":"true"}},[this._v("#")]),this._v(" 3xx 重定向")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("3xx响应结果表明服务器需要执行某些特殊的处理以正确处理请求")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("301 Moved Permanently")]),t._v(" (资源的URI已更新，你也更新下你的书签引用吧)"),_("br"),t._v("\n永久性重定向。 请求的资源已被分配了新的URL，以后应使用现在的URI。如果保存了书签，这时应该按Location首部字段提示的URI保存。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("302 Found")]),t._v(" (资源的URI已临时定位到其他位置，姑且算你已经知道这个情况了)"),_("br"),t._v("\n临时性重定向。  请求的资源已被分配了新的URL，希望用户(本次)能使用新的URI访问 不会更新书签")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("303 See Other")]),t._v("  (资源的URI已更新，你是否能临时按新的URI访问呢)"),_("br"),t._v("\n请求对象的资源存在着另外一个URI，应使用GET请求定向获取请求的资源")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("304 Not Modified")]),t._v(" (资源已找到，但是未符合条件请求 )"),_("br"),t._v("\n表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因为请求为未满足条件的情况后，直接返回304")]),t._v(" "),_("pre",[_("code",[t._v("  (服务器端资源未改变，可直接使用客户端未过期的缓存)\n  (并且不返回任何的响应主体部分，虽然304划分在3xx类别中，但是和重定向没有半毛钱关系)\n  附带条件的请求指的是：GET方法的请求报文中包含 If-Match If-None-Match If-Range If-Unmodified-since中的任一首部字段\n")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("307 Temporary Redirect")]),_("br"),t._v("\n临时重定向。与302有相同的含义，尽管302禁止POST变换为GET，但实际上大家并不遵守。307遵照浏览器标准不会将POST改为GET，但浏览器处理各不相同")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_4xx客户端错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4xx客户端错误","aria-hidden":"true"}},[this._v("#")]),this._v(" 4xx客户端错误")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("4xx的响应结果表明客户端是发生错误的原因所在。")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("400 Bad Request")]),t._v(" (我无法理解这个请求，是不是错了？)"),_("br"),t._v("\n请求报文中存在语法错误。浏览器会想200 ok一样对待改状态码")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("401 Unauthorized")]),t._v("    (本页面需要认证)"),_("br"),t._v("\n发送的请求你需要有通过HTTP认证(BASIC认证，DIGEST认证)的认证信息。若之前请求过一次，则用户认证失败。\n返回401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询(challenge)用户信息。当浏览器初次接收到401时，会弹出认证用的对话框。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("403 Forbidden")]),t._v(" (不允许访问那个资源哇)\n对请求资源的访问被服务器拒绝了。")]),t._v(" "),_("pre",[_("code",[t._v("  未获得文件系统的访问授权，访问权限出现某些问题时(从未授权的发送源IP地址试图访问)出现\n")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("404 Not Found")]),t._v(" (求的资源服务器没有请)"),_("br"),t._v("\n服务器上无法找到请求的资源，或者服务器端拒绝请求并且不想说明理由时用~")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_5xx服务器错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5xx服务器错误","aria-hidden":"true"}},[this._v("#")]),this._v(" 5xx服务器错误")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("5xx的响应结果表明服务器本身发生错误")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("500 Internal Server Error")]),t._v(" (内部资源出现故障)"),_("br"),t._v("\n服务器端在执行球球的时候发生错误。当然也可能是Web应用存在的bug或后写临时的故障导致。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("503 Service Unavailable")]),_("br"),t._v("\n服务器暂时处在超负荷或者正在停机维护，现在无法处理请求。")]),t._v(" "),_("pre",[_("code",[t._v("  如果事先得知解除以上状况需要的时间，最好写入 Retry-After首部字段给客户端。\n")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("此外，状态码和状态可能不一致，比如Web应用程序内部发生错误，状态码依然返回200 ok。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#udp","aria-hidden":"true"}},[this._v("#")]),this._v(" UDP")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("UDP 相比 TCP 简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，只会把想发的数据报文一股脑的丢给对端")]),this._v(" "),e("li",[this._v("虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp","aria-hidden":"true"}},[this._v("#")]),this._v(" TCP")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("建立连接需要三次握手，断开连接需要四次握手")]),this._v(" "),e("li",[this._v("滑动窗口解决了数据的丢包、顺序不对和流量控制问题")]),this._v(" "),e("li",[this._v("拥塞窗口实现了对流量的控制，保证在全天候环境下最优的传递数据")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"get-post"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-post","aria-hidden":"true"}},[this._v("#")]),this._v(" GET POST")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册")])]),t._v(" "),_("li",[_("p",[t._v("技术上：")]),t._v(" "),_("ul",[_("li",[t._v("Get 请求能缓存，Post 不能")]),t._v(" "),_("li",[t._v("Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的")]),t._v(" "),_("li",[t._v("URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的")]),t._v(" "),_("li",[t._v("Post 支持更多的编码类型且不对数据类型限制")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tls"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls","aria-hidden":"true"}},[this._v("#")]),this._v(" TLS")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密","aria-hidden":"true"}},[this._v("#")]),this._v(" 对称加密")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("两边拥有相同的秘钥，两边都知道如何将密文加密解密")]),this._v(" "),e("li",[this._v("这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"非对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密","aria-hidden":"true"}},[this._v("#")]),this._v(" 非对称加密")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。")]),this._v(" "),e("li",[this._v("这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"http2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP2")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用","aria-hidden":"true"}},[this._v("#")]),this._v(" 多路复用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("HTTP/2引入了"),e("code",[this._v("多路复用技术")]),this._v(",可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"二进制传输-所有加强性能的核心点在于此"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制传输-所有加强性能的核心点在于此","aria-hidden":"true"}},[this._v("#")]),this._v(" 二进制传输(所有加强性能的核心点在于此)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"header-压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#header-压缩","aria-hidden":"true"}},[this._v("#")]),this._v(" Header 压缩")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"服务端push"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务端push","aria-hidden":"true"}},[this._v("#")]),this._v(" 服务端push")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("服务端可以在客户端某个请求后，主动推送其他资源")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"http3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http3","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP3")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("HTTP2还有一个大问题，是底层支撑的TCP协议的问题。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("http2使用多路复用，一般一个域名下只需要一个TCP连接，当这个链接出现"),e("code",[this._v("丢包")]),this._v("，就会导致HTTP2的表现不如HTTP1.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Google 弄了一个基于 UDP 协议的 "),e("code",[this._v("QUIC")]),this._v(" 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC，接下来我们就来学习关于这个协议的内容。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"quic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#quic","aria-hidden":"true"}},[this._v("#")]),this._v(" QUIC")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"多路复用-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 多路复用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 "),e("code",[this._v("IP 和端口")]),this._v("去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 "),e("code",[this._v("ID")]),this._v(" 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_0-rtt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-rtt","aria-hidden":"true"}},[this._v("#")]),this._v(" 0-RTT")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"纠错机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#纠错机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 纠错机制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"输入-url-到页面渲染的整个流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#输入-url-到页面渲染的整个流程","aria-hidden":"true"}},[this._v("#")]),this._v(" 输入 URL 到页面渲染的整个流程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("首先 "),e("code",[this._v("DNS")]),this._v("查询，通过域名查找到具体的IP")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了")])]),t._v(" "),_("li",[_("p",[t._v("当 TCP 握手结束后就会进行 TLS 握手，然后就开始正式的传输数据。")])]),t._v(" "),_("li",[_("p",[t._v("数据在进入服务端之前，可能还会先经过负责"),_("code",[t._v("负载均衡的服务器")]),t._v("，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件")])]),t._v(" "),_("li",[_("p",[t._v("首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错")])]),t._v(" "),_("li",[_("p",[t._v("浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件")])]),t._v(" "),_("li",[_("p",[t._v("文件解码成功后会正式开始渲染流程")])]),t._v(" "),_("li",[_("p",[t._v("先会根据 HTML 构建 "),_("code",[t._v("DOM 树")]),t._v("，有 CSS 的话会去构建 "),_("code",[t._v("CSSOM 树")]),t._v("。如果遇到 script 标签的话，会判断是否存在 "),_("code",[t._v("async")]),t._v(" 或者 "),_("code",[t._v("defer")]),t._v(" ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。")])]),t._v(" "),_("li",[_("p",[t._v("CSSOM 树和 DOM 树构建完成后会开始生成 "),_("code",[t._v("Render 树")]),t._v("，这一步就是确定页面元素的布局、样式等等诸多方面的东西")])]),t._v(" "),_("li",[_("p",[t._v("在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。")])])])}],!1,null,null,null);i.options.__file="HTTP从入门到放弃.md";e.default=i.exports}}]);