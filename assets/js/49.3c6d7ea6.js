(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{238:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"时间复杂度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度","aria-hidden":"true"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),e("p",[t._v("通常使用最差的时间复杂度来衡量一个算法的好坏。")]),t._v(" "),e("p",[t._v("常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。")]),t._v(" "),e("p",[t._v("对于一个算法来说，可能会计算出操作次数为 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。")]),t._v(" "),e("p",[t._v("当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。")]),t._v(" "),e("h2",{attrs:{id:"栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#栈","aria-hidden":"true"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),e("blockquote",[e("p",[t._v("线性结构，只能在一端添加或删除， 先进后出")])]),t._v(" "),e("h2",{attrs:{id:"队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),e("blockquote",[e("p",[t._v("线性结构，一端添加一端删除，先进先出")])]),t._v(" "),e("h2",{attrs:{id:"链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表","aria-hidden":"true"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),e("blockquote",[e("p",[t._v("链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。")])]),t._v(" "),e("h2",{attrs:{id:"树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#树","aria-hidden":"true"}},[t._v("#")]),t._v(" 树")]),t._v(" "),e("blockquote",[e("p",[t._v("二分树 二分查找树 AVL 树 trie（又称前缀树或字典树）")])]),t._v(" "),e("h2",{attrs:{id:"并查集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并查集","aria-hidden":"true"}},[t._v("#")]),t._v(" 并查集")]),t._v(" "),e("h2",{attrs:{id:"堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆","aria-hidden":"true"}},[t._v("#")]),t._v(" 堆")])])}],!1,null,null,null);s.options.__file="index.md";a.default=s.exports}}]);