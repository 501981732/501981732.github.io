(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{229:function(n,t,e){"use strict";e.r(t);var o=e(0),i=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h3",{attrs:{id:"react-全局组件-toast-axios阻拦器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-全局组件-toast-axios阻拦器","aria-hidden":"true"}},[n._v("#")]),n._v(" react 全局组件  toast axios阻拦器")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("useage:\nToast.info('普通提示')\nToast.success('成功提示', 3000)\nToast.warning('警告提示', 1000)\nToast.error('错误提示', 2000, () => {\n    Toast.info('222')\n})\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("index.tsx 控制最终对外暴露的接口，根据外界传递的信息调用 Notification 组件的添加方法以向页面中添加提示信息组件\ntoast.tsx 无状态组件 只负责根据父组件传递的参数渲染为对应提示信息的组件\nnotification.js toast组件的容器，用于保存页面存在的toast组件并提供Notice组件的添加和移除方法\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("toast.tsx\nimport React from 'react';\nimport './index.scss';\n// 只需要根据 Notification 组件传递的信息输出最终的内容\ninterface Props {\n    type?:string;\n    content?:string;\n    children?:any;\n}\nconst Toast:React.SFC<Props> = (props) => {\n    const { type, content,children } = props\n    return (\n        <div className={`c-toast ${type}-notice`}>\n            {children ? children : content}\n        </div>\n    )\n}\n\nexport default React.memo(Toast)\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("notification.tsx\nimport React from 'react'\nimport {TransitionGroup, CSSTransition } from 'react-transition-group'\nimport Toast from './toast'\nimport './index.scss';\n\nexport interface Istate {\n    notices: any[]\n}\nexport interface Iprops {\n    \n}\n// notice 用于保存当前页面中存在的 Notice 的信息。\n// Notification 组件拥有 addNotice 和 removeNotice 两个方法，用于向 notices 中添加和移除 Notice 的信息\n\nexport default class Notification extends React.Component<Iprops,Istate> {\n    constructor(props:Iprops) {\n        super(props)\n        this.state = { notices: [] }\n    }\n    getNoticeKey() {\n        const {notices} = this.state\n        return `notice-${new Date().getTime()}-${notices.length}`\n    }\n    addNotice = (notice:any) => {\n        const { notices } = this.state\n        notice.key = this.getNoticeKey()\n        if(notices.every(item => item.key !== notice.key)) {\n            notices[0] = notice\n            this.setState({ notices })\n            if (notice.duration > 0) {\n                setTimeout(() => {\n                    this.removeNotice(notice.key)\n                }, notice.duration)\n            }\n        }\n    }\n\n    removeNotice = (key:string) => {\n        this.setState(previousState => ({\n            notices: previousState.notices.filter((notice) => {\n                if (notice.key === key) {\n                    if (notice.onClose) notice.onClose()\n                    return false\n                }\n                return true\n            })\n        })) \n    }\n    render() {\n        const {notices} = this.state \n        return (\n            <TransitionGroup className=\"c-toast-notification\">\n                {\n                    notices.map(notice => (\n                        <CSSTransition\n                            key={notice.key}\n                            classNames=\"c-toast-notice-wrapper c-fade\"\n                            // timeout={notice.duration}\n                            timeout={3000}\n                        >\n                            <Toast {...notice} />\n                        </CSSTransition>\n                    ))\n                }\n            </TransitionGroup>\n        )\n    }\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("index.tsx\n// 全局组件\n//设置默认的参数值，全局创建或销毁Toast的DIV\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport Notification from './notification'\n\n\ninterface returnInfo {\n    addNotice: (notice:any) => any\n    destory: () => void\n}\nexport interface NotificationApi {\n    info(args:any): void;\n    success(args:any): void;\n    error(args:any):void;\n    warning(args:any):void;\n    open(args:any):void;\n    close(args:any):void;\n    config(options:any):void;\n    destory():void\n}\nexport type noticeInfo = {\n    type?:string;\n    content: string;\n    duration?: string| number;\n    onClose():void\n}\nfunction createNotification():returnInfo {\n    const div:HTMLDivElement = document.createElement('div')\n    document.body.appendChild(div)\n    const notification = ReactDOM.render((<Notification /> as any),div)\n    return {\n        addNotice(notice:any) {\n            return (notification as any).addNotice(notice)\n        },\n        destory() {\n            ReactDOM.unmountComponentAtNode(div)\n            document.body.removeChild(div)\n        }\n    }\n}\n\n// 定义一个全局的 notification 变量用于保存 createNotification 返回的对象\nlet notification:any\nconst notice = ({type='info', content, duration= 2000, onClose}:noticeInfo) => {\n    if (!notification) notification = createNotification()\n    return notification.addNotice({ type, content, duration, onClose })\n}\n\nconst api:any = {\n    open() {\n\n    },\n    close(key:string) {\n\n    },\n    config() {\n\n    },\n    destory() {\n\n    }\n};\n['info','success','error','warning'].forEach(type => {\n    api[type] = (args:any) => {\n        return notice({...args,type})\n    }\n})\nexport default api as NotificationApi\n\n")])])])])}],!1,null,null,null);i.options.__file="react全局组件.md";t.default=i.exports}}]);