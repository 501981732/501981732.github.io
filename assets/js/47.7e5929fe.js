(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{191:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),n("embed",{attrs:{src:"/img/性能优化--1.缓存.pdf",width:"500",height:"375",type:"application/pdf"}}),t._v(" "),t._m(2),t._v(" "),n("embed",{attrs:{src:"/img/性能优化--1.缓存.pdf",width:"500",height:"375",type:"application/pdf"}}),t._v(" "),t._m(3),t._v(" "),n("embed",{attrs:{src:"/img/性能优化--3.渲染篇.pdf",width:"500",height:"375",type:"application/pdf"}}),t._v(" "),t._m(4),t._v(" "),n("embed",{attrs:{src:"/img/性能优化--4.应用篇.pdf",width:"500",height:"375",type:"application/pdf"}}),t._v(" "),t._m(5),t._v(" "),n("ol",[t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),n("li",[n("p",[t._v("web本地存储\n-localStorage 5M内存，but超过2.5M某些机型会卡顿")]),t._v(" "),n("ul",[t._m(12),t._v(" "),n("li",[t._v("webSQL关系型")]),t._v(" "),n("li",[t._v("indexedDB非关系型 是webSQL的继承者更加好用")]),t._v(" "),n("li",[n("a",{attrs:{href:"https://localforage.docschina.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("localforage"),n("OutboundLink")],1),t._v(" 为你解决一切，针对浏览器做降级处理本地存储")]),t._v(" "),n("li",[t._v("manifest 更新是个坑")]),t._v(" "),n("li",[t._v("service worker 拦截掉本地所有网络请求 //需要编写一定量的代码")])])]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18)]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),t._m(47),t._m(48),t._v(" "),t._m(49),t._v(" "),t._m(50),t._v(" "),t._m(51),t._v(" "),t._m(52),t._v(" "),t._m(53),t._v(" "),t._m(54),t._v(" "),t._m(55),t._v(" "),t._m(56),t._v(" "),t._m(57),t._v(" "),t._m(58),t._v(" "),t._m(59),t._m(60),t._v(" "),t._m(61),t._v(" "),t._m(62),t._v(" "),t._m(63),t._v(" "),t._m(64),t._v(" "),t._m(65),t._v(" "),t._m(66),t._v(" "),t._m(67),t._v(" "),t._m(68),t._v(" "),t._m(69),t._v(" "),t._m(70),t._v(" "),t._m(71),t._v(" "),t._m(72),t._v(" "),t._m(73),t._v(" "),t._m(74),t._v(" "),t._m(75),t._v(" "),t._m(76),t._v(" "),t._m(77),t._v(" "),t._m(78),t._v(" "),t._m(79),t._v(" "),t._m(80),t._v(" "),t._m(81),t._m(82),t._v(" "),t._m(83),t._m(84),t._v(" "),t._m(85),t._v(" "),t._m(86),t._v(" "),t._m(87),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端性能优化清单"),n("OutboundLink")],1),t._v(" "),n("a",{attrs:{href:"https://cherryblog.site/front-end-performance-checklist-2018.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端性能优化清单"),n("OutboundLink")],1),t._v(" "),n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/30558018",target:"_blank",rel:"noopener noreferrer"}},[t._v("从Chrome源码看浏览器如何加载资源"),n("OutboundLink")],1)])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"总结篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结篇","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结篇")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("a",{attrs:{href:"/img/性能优化--1.缓存.pdf"}},[this._v("性能优化--1.缓存")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("a",{attrs:{href:"/img/性能优化--2.网络篇.pdf"}},[this._v("性能优化--2.网络篇")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("a",{attrs:{href:"/img/性能优化--3.渲染篇.pdf"}},[this._v("性能优化--3.渲染篇")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("a",{attrs:{href:"/img/性能优化--4.应用篇.pdf"}},[this._v("性能优化--4.应用篇")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 性能优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("html css js img 最简单的压缩合并 YUI Compressor tinyPNG https://zh.recompressor.com/")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("雅虎军规")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("服务器端的：etag gzip")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("第三方库代码：资源压缩 强缓etag jq vue")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("渐进式图片加载 首先加载低质量或模糊的图像，然后在页面继续加载时，使用 Guy Podjarny 提出的 LQIP (Low Quality Image Placeholders) technique（低质量图像占位符）技术替换它们的清晰版本")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("业务代码：大容量的解决方案 -> 异步")]),this._v(" "),e("ul",[e("li",[this._v("html css js -> 数据库里 h5页面localstorage扩容（postmessage）")]),this._v(" "),e("li",[this._v("将本地资源已key:value形式存入localstorage,请求文件前先对比请求的资源和相应的key是否匹配，匹配的话就读取激活对应的文件，否则再去请求资源")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("strong",[this._v("localStorage扩容")]),this._v(" 5M的限制是针对同域的，可以利用iframe跨域扩容localStorage（postmessage），不过这种就是异步的了")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[e("strong",[this._v("移动端测试网速方案")]),this._v("(根据网速判断是加载二倍图还是三杯图)")]),this._v(" "),e("ul",[e("li",[this._v("navigator.connection")]),this._v(" "),e("li",[this._v("服务端放个1*1图片 客户端new Image() 测时差"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let img = new Image();\n    const size = 1\n        img.src = ''     // 假如是个1k的图片\n    let start = Date.now()\n        img.onLoad = function() {\n            let end = Date.now()\n            let speed = size / (end - start) / 1000   网速 \n            if( )\n        }\n")])])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("cdn 1.找到离你最近")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("缓存静态资源")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("不用带那么多cookie")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("并发数量有限制 不放一个cdn")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("dns预解析 dns-prefetch")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("在某些浏览器中这个预读取的行为将会与页面实际内容并行发生（而不是串行）。正因如此，某些高延迟的域名的解析过程才不会卡住资源的加载。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("这样可以极大的加速（尤其是移动网络环境下）页面的加载。在某些图片较多的页面中，在发起图片加载请求之前预先把域名解析好将会有至少 5% 的图片加载速度提升\n"),e("code",[this._v("<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"> <link href='j1.58cdn.com' rel='dns-prefetch'>")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"13"}},[e("li",[e("p",[this._v("preconnect预链接\n浏览器要建立一个连接，一般需要经过DNS查找，TCP三次握手和TLS协商（如果是https的话），这些过程都是需要相当的耗时的，所以preconnect，就是一项使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了。")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('<link rel="preconnect" href="//example.com">\n<link rel="preconnect" href="//cdn.example.com" crossorigin>\n')])])])]),this._v(" "),e("li",[e("p",[this._v("/prefetch/preload/")])]),this._v(" "),e("li",[e("p",[this._v("测网速 判断 然后 2倍图3倍图 去掉无用功能 只留核心组件")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"webpack优化部分-构建优化部分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化部分-构建优化部分","aria-hidden":"true"}},[this._v("#")]),this._v(" webpack优化部分 构建优化部分")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"压缩js（去掉无效代码、去掉日志输出代码、缩短变量名等优化。）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩js（去掉无效代码、去掉日志输出代码、缩短变量名等优化。）","aria-hidden":"true"}},[this._v("#")]),this._v(" 压缩JS（去掉无效代码、去掉日志输出代码、缩短变量名等优化。）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- **uglifyjs-webpack-plugin** or **new webpack.optimize.UglifyJsPlugin** \n- **webpack-parallel-uglify-plugin** 多进程压缩文件,类似happyPack\n\n ```\n const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');\n   new ParallelUglifyPlugin({\n      // 传递给 UglifyJS 的参数\n      uglifyJS: {\n        output: {\n          // 最紧凑的输出\n          beautify: false,\n          // 删除所有的注释\n          comments: false,\n        },\n        compress: {\n          // 在UglifyJs删除没有用到的代码时不输出警告\n          warnings: false,\n          // 删除所有的 `console` 语句，可以兼容ie浏览器\n          drop_console: true,\n          // 内嵌定义了但是只用到一次的变量\n          collapse_vars: true,\n          // 提取出出现多次但是没有定义成变量去引用的静态值\n          reduce_vars: true,\n        }\n      },\n    }),\n ```\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"压缩css-css-loader已经内置开启-minimize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩css-css-loader已经内置开启-minimize","aria-hidden":"true"}},[this._v("#")]),this._v(" 压缩CSS css-loader已经内置开启 "),e("strong",[this._v("minimize")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("```\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nrules: [\n  {\n    test: /\\.css/,\n    // 提取出 Chunk 中的 CSS 代码到单独的文件中\n    use: ExtractTextPlugin.extract({\n      // 通过 minimize 选项压缩 CSS 代码\n      use: ['css-loader?minimize']\n    }),\n  },\n]\n```\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"缩小文件搜索范围-构建时优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缩小文件搜索范围-构建时优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 缩小文件搜索范围 构建时优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("-  配置**loader 缓存** 以及**include exclude**\n```\n    rules: [\n      {\n        // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能\n        test: /\\.js$/,\n        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启\n        use: ['babel-loader?cacheDirectory'],\n        // 只对项目根目录下的 src 目录中的文件采用 babel-loader\n        include: path.resolve(__dirname, 'src'),\n      },\n    ]\n```\n- 配置 **resolve.modules**(resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。)\n\n```\nmodule.exports = {\n  resolve: {\n    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\n    modules: [path.resolve(__dirname, 'node_modules')]\n  },\n};\n```\n- 配置**resolve.mainFields** 字段 （慎用 除非你知道你用的所有第三方模块的入口文件描述）\n\n```\n    第三方包可能有根据不同的运行环境有多个入口文件\n    为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。\n  resolve: {\n    // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤\n    mainFields: ['main'],\n    },\n```\n- 配置 **resove.alias**\n\n```\n  resolve: {\n    // 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，\n    // 减少耗时的递归解析操作\n    alias: {\n    'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js'),\n}\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("},\n```\n- 配置 "),e("strong",[this._v("resolve.extensions")]),this._v(" (配置后缀默认 ['.js','.json']) 尽可能较少默认后缀 频繁使用的放前面 等")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"externals（外部扩展）从代码中拆公共模块，走cdn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#externals（外部扩展）从代码中拆公共模块，走cdn","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("externals")]),this._v("（外部扩展）从代码中拆公共模块，走cdn")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("```\n  externals: {  \n     'vue': 'Vue',  \n     'vue-router': 'VueRouter',  \n     'axios': 'axios'  \n   }\n```\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"cdn加速"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn加速","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("cdn加速")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("业界比较成熟的做法：\n- 针对HTML 不开启缓存，放到服务器上而不是CDN，同时关闭自己服务器上的缓存，服务器会提供HTML和接口数据\n- 针对静态JS CSS IMAGE等，开启CDN和缓存，同时文件内容带上hash\n- 同时HTML进入资源地址也要改成CDN的地址 带上hash 之前的相对路径都改成了指向CDN服务的结对路径\n- 同一时刻针对同一个域名的资源并行请求是有限制的话，所以会把js css img 分别放到3个cdn下 js.cdn.com css.cdn.com img.cdn.com\n- 当然多域名 又会增加域名解析时间。 可以通过 **CDN预解析** 较少解析带来的延迟\nwebpack 接入cdn\n\n```\nconst path = require('path');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst {WebPlugin} = require('web-webpack-plugin');\nmodule.exports = {\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("...\noutput: {\n// 给输出的 JavaScript 文件名称加上 Hash 值\nfilename: '[name]"),e("em",[this._v("[chunkhash:8].js',\npath: path.resolve(__dirname, './dist'),\n// 指定存放 JavaScript 文件的 CDN 目录 URL\npublicPath: '//js.cdn.com/id/',\n},\nmodule: {\nrules: [\n{\n// 增加对 CSS 文件的支持\ntest: /.css/,\n// 提取出 Chunk 中的 CSS 代码到单独的文件中\nuse: ExtractTextPlugin.extract({\n// 压缩 CSS 代码\nuse: ['css-loader?minimize'],\n// 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL\npublicPath : '//img.cdn.com/id/'\n}),\n},\n{\n// 增加对 PNG 文件的支持\ntest: /.png/,\n// 给输出的 PNG 文件名称加上 Hash 值\nuse: ['file-loader?name=[name]")]),this._v("[hash:8].[ext]'],\n},\n...\n]\n},\nplugins: [\nnew WebPlugin({\ntemplate: './template.html',\nfilename: 'index.html',\n// 指定存放 CSS 文件的 CDN 目录 URL\nstylePublicPath: '//css.cdn.com/id/',\n}),\nnew ExtractTextPlugin({\n// 给输出的 CSS 文件名称加上 Hash 值\nfilename: "),e("code",[this._v("[name]_[contenthash:8].css")]),this._v(",\n}),\n//keep module.id stable when vendor modules does not change\nnew webpack.HashedModuleIdsPlugin(),\n],\n};")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("```\n我一般是通过loader来配置图片的cdn\n\n```\n区分环境 生产环境下加载cdn图片，并且启用图片压缩，开发环境下加载本地图片\nconst ISPROD = process.env.NODE_ENV === 'production'\nconst IMGURL = '[name].[ext]'\nconst IMAGELOADER = ISPROD ? `image-webpack-loader?{mozjpeg: {progressive: true,quality: 65},pngquant:{quality: \"55-80\", speed: 4}}` : null\nconst IMG_PUBLICPATH = '//img.58cdn.com.cn/crop/baseteam/yunying/pc/gzpp/img/'\nconst IMG_QUERY = ISPROD ? `&name=${IMGURL}&outputPath=/img&publicPath=${IMG_PUBLICPATH}` : `&name=${DEVIMGURL}`\n{\n    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n    use: [\n        `url-loader?limit=10000${IMG_QUERY}`,\n        IMAGELOADER,\n    ]\n},\n```\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"图片压缩-示例如上-image-webpack-plugin-或者-imagemin-webpack-plugin-等"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片压缩-示例如上-image-webpack-plugin-或者-imagemin-webpack-plugin-等","aria-hidden":"true"}},[this._v("#")]),this._v(" 图片压缩 示例如上 "),e("strong",[this._v("image-webpack-plugin")]),this._v(" 或者 "),e("strong",[this._v("imagemin-webpack-plugin")]),this._v(" 等")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"cdn-预解析-加上-dns-prefetch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn-预解析-加上-dns-prefetch","aria-hidden":"true"}},[this._v("#")]),this._v(" cdn 预解析 加上 "),e("strong",[this._v("dns-prefetch")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"dll-动态链接库-dllplugin和dllreferenceplugin-可以搭配-html-webpack-include-assets-plugin-来动态在模板上引入dll"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dll-动态链接库-dllplugin和dllreferenceplugin-可以搭配-html-webpack-include-assets-plugin-来动态在模板上引入dll","aria-hidden":"true"}},[this._v("#")]),this._v(" dll 动态链接库 "),e("strong",[this._v("DllPlugin和DllReferencePlugin")]),this._v(" 可以搭配 "),e("strong",[this._v("html-webpack-include-assets-plugin")]),this._v(" 来动态在模板上引入dll")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 区别 CommonsChunkPlugin：webpack每次打包实际还是会处理这些第三方库，但是打包之后能和第三方库和我们业务代码分开，DLLPlugin 可提前把第三方库完全分开，每次只打包自己业务代码\n- 区别 externals：\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"提取公共代码commonschunkplugin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提取公共代码commonschunkplugin","aria-hidden":"true"}},[this._v("#")]),this._v(" 提取公共代码CommonsChunkPlugin")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("一般策略是 \n1. 第三方基本库放到一个js中(为了缓存)\n2. 剔除第三方基本库公共部分放一个js\n3. 每个页面自己的js\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"tree-shaking"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("tree shaking")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v('- 第三方采用的commonJS是无效的 因为 ES6 模块化语法是静态的（导入导出语句中的路径必须是静态的字符串，而且不能放入其它代码块中），这让 Webpack 可以简单的分析出哪些 export 的被 import 过了。 如果你采用 ES5 中的模块化，例如 module.export={...}、require(x+y)、if(x){require(\'./util\')}，Webpack 无法分析出哪些代码可以剔除。\n- 一般第三方库会有两个入口文件\n\n```\n如redux package.json\n{\n    "main": "lib/index.js", // 指明采用 CommonJS 模块化的代码入口\n    "jsnext:main": "es/index.js" // 指明采用 ES6 模块化的代码入口 （社区约定）\n}\n1. webpack约定优先入口文件\nresolve: {\n    mainFields: [\'jsnext:main\', \'browser\', \'main\']\n},\n2. 修改.babelrc 让其保留 ES6 模块化语句\n{\n    "presets": [\n    [\n        "env",\n    {\n        "modules": false //关闭babel模块转化功能\n    }\n    ]\n  ]\n}\n3. webpack只是指出那些函数没用上，还要通过UglifyJS 去剔除掉无用的代码\n```\n')])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"启用-scope-hoisting-作用域提升-new-webpack-optimize-moduleconcatenationplugin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启用-scope-hoisting-作用域提升-new-webpack-optimize-moduleconcatenationplugin","aria-hidden":"true"}},[this._v("#")]),this._v(" 启用 "),e("strong",[this._v("scope hoisting")]),this._v("  作用域提升   new webpack.optimize.ModuleConcatenationPlugin()")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("好处\n- 代码体积更小，因为函数申明语句会产生大量代码；\n- 代码在运行时因为创建的函数作用域更少了，内存开销也随之变小。\n- 前提： **tree shake**一样源码必须采用 ES6 模块化语句和 \n- [scope hoisting原理](#scopehositing)\n\t- 分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。 因此只有那些被引用了一次的模块才能被合并。  \n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("module.exports = {\n  resolve: {\n    mainFields: ['jsnext:main', 'browser', 'main']\n  },\n  plugins: [\n    new webpack.optimize.ModuleConcatenationPlugin(),\n  ],\n};\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"prepack-优化代码运行时的效率-目前技术不成熟，慎用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prepack-优化代码运行时的效率-目前技术不成熟，慎用","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("prepack")]),this._v("(优化代码运行时的效率 目前技术不成熟，慎用)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 在保持运行结果一致的情况下，改变源代码的运行逻辑，输出性能更高的 JavaScript 代码。 实际上 Prepack 就是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。 \n- 通过在编译阶段预先执行了源码得到执行结果 prepack-webpack-plugin\n- [prepack运行原理](#prepack) \n\t- 通过 Babel 把 JavaScript 源码解析成抽象语法树（AST），以方便更细粒度地分析源码；\n\t- Prepack 实现了一个 JavaScript 解释器，用于执行源码。借助这个解释器 Prepack 才能掌握源码具体是如何执行的，并把执行过程中的结果返回到输出中。\n- prepack目前技术不成熟 慎用\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"happypack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#happypack","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("happypack")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 构建时优化，任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n- [hanppyPack原理]()：把 Loader 对文件的转换操作部分任务分解到多个进程去并行处理，从而减少了总的构建时间。把 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。\n\t1. 每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。\n\n\t2. 核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。\n\n\t3. 核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。\n\n```\n\nconst HappyPack = require('happypack');\n// 构造出共享进程池，进程池中包含5个子进程\nconst happyThreadPool = HappyPack.ThreadPool({ size: 5 });\n\nmodule.exports = {\n module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例\n        use: ['happypack/loader?id=babel'],\n        exclude: path.resolve(__dirname, 'node_modules'),\n      },\n      {\n        // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例\n        test: /\\.css$/,\n        use: ExtractTextPlugin.extract({\n          use: ['happypack/loader?id=css'],\n        }),\n      },\n    ]\n  },\n  plugins: [\n    new HappyPack({\n      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件\n      id: 'babel',\n      // 如何处理 .js 文件，用法和 Loader 配置中一样\n      loaders: ['babel-loader?cacheDirectory'],\n      // 使用共享进程池中的子进程去处理任务\n      threadPool: happyThreadPool,\n    }),\n    new HappyPack({\n      id: 'css',\n      // 如何处理 .css 文件，用法和 Loader 配置中一样\n      loaders: ['css-loader'],\n      // 使用共享进程池中的子进程去处理任务\n      threadPool: happyThreadPool,\n    }),\n  ],\n};\n```\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"prefetch-preload"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prefetch-preload","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("prefetch/preload")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- [webopack4已支持](https://webpack.docschina.org/guides/code-splitting/#prefetching-preloading-modules) 但是4.6之后才支持\n\n```\nimport(/* webpackPreload: true */ 'ChartingLibrary');\nimport(/* webpackPrefetch: true */ 'LoginModal');\n```\n- 或借用插件\n\t1.  [webpack插件resource-hints-webpack-plugin](https://github.com/jantimon/resource-hints-webpack-plugin) similarly no async chunk support\n\t2. [preload-webpack-plugin](https://github.com/vuejs/preload-webpack-plugin)\n    3. [[译]Preload，Prefetch 和它们在 Chrome 之中的优先级](https://juejin.im/post/58e8acf10ce46300585a7a42?utm_source=gold-miner&utm_medium=readme&utm_campaign=github)\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"按需加载-webpack有强大的代码分割能力"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按需加载-webpack有强大的代码分割能力","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("按需加载")]),this._v(" webpack有强大的代码分割能力")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("```\nimport(/* webpackChunkName: \"show\" */ './show')\n```\n\n**webpack支持import语法的支持**，当执行到import时\n\n- 以 ./show.js 为入口新生成一个 Chunk；\n- 当代码执行到 import 所在语句时才会去加载由 Chunk 对应生成的文件。\n- import 返回一个 Promise，当文件加载成功时可以在 Promise 的 then 方法中获取到 show.js 导出的内容。\n- /* webpackChunkName: \"show\" */ 为动态生成的文件取名字， OR 默认[id].js,当然为了正确输出文件名字 需要配置出口\n- babel-plugin-syntax-dynamic-import\n\n```\nmodule.exports = {\n  output: {\n    // 为动态加载的 Chunk 配置输出文件的名称\n    chunkFilename: '[name].js',\n  }\n};\n```\n\n- vue按需加载： 结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\n\n```\nvue按需加载比较简单\n\nconst index = () => import(/* webpackChunkName: \"index\" */ \"@/components/index.vue\");\n```\n- react按需加载Router \n\n```\nimport React, {PureComponent, createElement} from 'react';\nimport {render} from 'react-dom';\nimport {HashRouter, Route, Link} from 'react-router-dom';\nimport PageHome from './pages/home';\n\n/**\n * 异步加载组件\n * @param load 组件加载函数，load 函数会返回一个 Promise，在文件加载完成时 resolve\n * @returns {AsyncComponent} 返回一个高阶组件用于封装需要异步加载的组件\n */\nfunction getAsyncComponent(load) {\n  return class AsyncComponent extends PureComponent {\n\n    componentDidMount() {\n      // 在高阶组件 DidMount 时才去执行网络加载步骤\n      load().then(({default: component}) => {\n        // 代码加载成功，获取到了代码导出的值，调用 setState 通知高阶组件重新渲染子组件\n        this.setState({\n          component,\n        })\n      });\n    }\n\n    render() {\n      const {component} = this.state || {};\n      // component 是 React.Component 类型，需要通过 React.createElement 生产一个组件实例\n      return component ? createElement(component) : null;\n    }\n  }\n}\n\n// 根组件\nfunction App() {\n  return (\n    <HashRouter>\n      <div>\n        <nav>\n          <Link to='/'>Home</Link> | <Link to='/about'>About</Link> | <Link to='/login'>Login</Link>\n        </nav>\n        <hr/>\n        <Route exact path='/' component={PageHome}/>\n        <Route path='/about' component={getAsyncComponent(\n          // 异步加载函数，异步地加载 PageAbout 组件\n          () => import(/* webpackChunkName: 'page-about' */'./pages/about')\n        )}\n        />\n        <Route path='/login' component={getAsyncComponent(\n          // 异步加载函数，异步地加载 PageAbout 组件\n          () => import(/* webpackChunkName: 'page-login' */'./pages/login')\n        )}\n        />\n      </div>\n\t</HashRouter>\n```\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"分析插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分析插件","aria-hidden":"true"}},[this._v("#")]),this._v(" 分析插件")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- webpack-bundle-analyzer\n- webpack --profile --json 记录构件耗时并输出json文件\n- [Webpack Analyse](http://webpack.github.io/analyse/)官方可视化工具\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"hrm-模块热替换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hrm-模块热替换","aria-hidden":"true"}},[this._v("#")]),this._v(" HRM 模块热替换")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("   new webpack.HotModuleReplacementPlugin(), //当启动时带上 `--hot` 参数会自动调用\n   new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"接入serviceworker-workbox-webpack-plugin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接入serviceworker-workbox-webpack-plugin","aria-hidden":"true"}},[this._v("#")]),this._v(" 接入serviceWorker workbox-webpack-plugin")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- wokbox 是用于向web应用程序添加离线支持的JavaScript库。\n- https://segmentfault.com/a/1190000019281388?utm_source=tag-newest\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"gpu加速原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gpu加速原理","aria-hidden":"true"}},[this._v("#")]),this._v(" GPU加速原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"网页的渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网页的渲染过程","aria-hidden":"true"}},[this._v("#")]),this._v(" 网页的渲染过程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("1. 获取dom 分割成多个层\n2. 对每个图层的节点计算样式结果 （Recalculate style）\n3. 为每个节点生成图形和位置 layout \n4. 将每个节点绘制并填充到图形的位置中 paint \n5. 图层作为纹理上传到GPU\n6. 符合条件的多图层生成屏幕的图像  Composite layer 合成层\n7.浏览器渲染过程 layout -> paint -> composite layer （触发的阶段越高，代价越高）\n\n独立的层 --\x3e重排重绘 不会影响父层\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"哪些些会生成独立的层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哪些些会生成独立的层","aria-hidden":"true"}},[this._v("#")]),this._v(" 哪些些会生成独立的层")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("1. 根元素 position transform 半透明 canvas video overflow 滤镜...\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"哪些属性可以开启gpu加速"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哪些属性可以开启gpu加速","aria-hidden":"true"}},[this._v("#")]),this._v(" 哪些属性可以开启GPU加速")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v(" - 虽然生成独立的层，但是还是cpu一直在计算重绘重排，再传到GPU 进行合成\n- 开启GPU加速后 就省去CPU重排重绘的过程 GPU(图形处理器)擅长图形处理   (gpu.js)\n- css3d video webgl transfrom css滤镜 flash z-index大于某个相邻节点的layer元素... \n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"硬件加速（gpu加速）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#硬件加速（gpu加速）","aria-hidden":"true"}},[this._v("#")]),this._v(" 硬件加速（GPU加速）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 术语：Texture 即CPU传到GPU的一个Bitmap\n- GPU 能对 快速对Texture 进行 偏移 旋转，缩放，修改透明度等\n- 节约了 \n    1. CPU进行layout paint 的时间 \n    2. CPU上传位图的时间\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"cpu-vs-gpu"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu-vs-gpu","aria-hidden":"true"}},[this._v("#")]),this._v(" CPU VS GPU")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 相同：都有总线与外界联系，有自己的缓存体系，以及数字与逻辑运算单元，两者都是为了完成计算任务而设计的\n- 不同：CPU 主要处理操作系统和应用程序 GPU主要处理跟显示相关的数据处理， GPU的活一般CPU都能干，但是效率低\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"layer模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#layer模型","aria-hidden":"true"}},[this._v("#")]),this._v(" layer模型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 浏览器根据css属性生成layer\n- 将layer作为Texture上传GPU\n- 当改变layer的transfrom opacity 等属性，渲染会跳过 layout paint 直接通知GPU做出改变\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘","aria-hidden":"true"}},[this._v("#")]),this._v(" 重绘")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- border-raduis box-shadow color ...\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"重排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排","aria-hidden":"true"}},[this._v("#")]),this._v(" 重排")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("- 跳过优化（浏览器对重排有一定的优化，合并多次重排）读取 offsetTop scrollTop width clientWidth getComputedStyle() getBoundingClientRect()\n- 删除位置 大小 盒子\n- 读写分离   **fastdom.js**\n\n```\nvar h = document.getElementById('h').clientHeight\n//写操作放到下一帧 （假如下一针有大量的操作，requestAnimationFrame会自动调整帧数从60FPS降到30FPS，不会导致丢帧）\n    requestAnimationFrame(function(){\n        xxx.style.height = h*2\n    })\n```\n- display:none -> block 重绘重排  visibility:visible -> hidden \n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("##. 直出\n- 假如多页的话，每次跳转都会重新加载你以来的vue react\n- 假如SPA单页面：访问html文件 -> 初始化路由 -> 找到对应跟路由 -> 找到对应组件 ->发请求 发给后端再渲染   导致"),e("strong",[this._v("白屏")]),this._v("\n- "),e("strong",[this._v("SSR + SPA")]),this._v(" 用户访问到网站直接吐html\n- 多页转单页 "),e("strong",[this._v("pushstate技术")]),this._v(' a/b ->c/d 检测到路由变化向后台发请求\n- 如果header是ajax （"X-Requested-With":"XMLHttpRequest"）就是单页，不是render')])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ol",{attrs:{start:"13"}},[n("li",[t._v("利用缓存技术(localStorage indexedDB webSQL等)\n"),n("ol",[n("li",[t._v("缓存关键路径里的js资源。（微信）\n第一次访问时将js放到缓存中，每次进来取出来执行")])]),t._v(" "),n("ul",[n("li",[t._v("关键点是设计一套缓存更新机制。对缓存的js增加后缀(时间戳或hash等)来设置独一无二的版本标识。")]),t._v(" "),n("li",[t._v("每次后端同步传一份资源的配置文件，FE根据配置文件和缓存中的文件进行版本标识。从而决定是利用缓存还是重新请求。")])]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("利用缓存对关键的XHR异步请求进行缓存。（天猫超市）")])]),t._v(" "),n("ul",[n("li",[t._v("天猫超时首页对首屏中的轮播和10个分类入口的数据进行了缓存。提升首屏的渲染展示时间。")])]),t._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[t._v("对非关键请求进行缓存(狗东pc)")])]),t._v(" "),n("ul",[n("li",[t._v("将非首屏资源的HTML/CSS等资源抽出来放在LS内，当页面滚动到可视区域时再去LS中获取数据，插入到dom中。\n"),n("img",{attrs:{src:"/img/wx_cache.png",alt:"wx"}})])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('wx\nwindow.__moon_map = {"pages/iframe_communicate.js":"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/iframe_communicate42f400.js","new_video/player.html.js":"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player.html433882.js",}\n\n58.com 下localstorage\nclv\n{j1.58cdn.com.cn/componentsLoader/dist/PopCollection.js: "20180427170320"\nj1.58cdn.com.cn/componentsLoader/dist/PopupBind.js: "20181221193411"\nj1.58cdn.com.cn/componentsLoader/dist/PopupLogin.js: "20181221193411"\nj1.58cdn.com.cn/git/passport-popupwarn/BindBefore.js: "20181201104527"\nj1.58cdn.com.cn/git/passport-popupwarn/MobileSure.js: "20181201104527"\nj1.58cdn.com.cn/git/passport-popupwarn/Warn.js: "20181201104527"\nj1.58cdn.com.cn/git/private-phone-call-pc/dist/js/bundle_pc_generate.js: "0"\nupdateTime: 1555060912448//现在的时间戳\n}\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("请打开chrome工具对比 preference timeingline")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('对比 preference timeingline\n<!DOCTYPE html>\n<html lang="en">\n<head>\n\t<meta charset="UTF-8">\n\t<title>Document</title>\n</head>\n<style>\n\t.container {\n\t\tposition: relative;\n\t}\n\t#ball,#ball2 {\n\t\tposition: absolute;\n\t\tborder-radius: 50%;\n\t\tbox-shadow: 0 0 5px 0 red;\n\t\twidth: 100px;\n\t\theight: 100px;\n\t}\n\t#ball2 {\n\t\tbox-shadow: 0 0 5px 0 gray;\n\t}\n\t.run {\n\t\tanimation: running-circle 3s infinite;\n\t}\n\t.run2 {\n\t\tanimation: running-circle2 3s infinite;\n\t}\n\t@keyframes running-circle {\n\t\t0% {\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t}\n\t\t25% {\n\t\t\ttop: 0px;\n\t\t\tleft: 200px;\n\t\t}\n\t\t50% {\n\t\t\ttop: 200px;\n\t\t\tleft: 200px;\n\t\t}\n\t\t75% {\n\t\t\ttop: 200px;\n\t\t\tleft: 0px;\n\t\t}\n\t\t100% {\n\t\t\ttop: 0px;\n\t\t\tleft: 0px;\n\t\t}\n\t}\n\t@keyframes running-circle2 {\n\t\t0% {\n\t\t\ttransform: translate(0,0)\n\t\t}\n\t\t25% {\n\t\t\ttransform: translate(0,200px)\n\t\t}\n\t\t50% {\n\t\t\ttransform: translate(200px,200px)\n\t\t}\n\t\t75% {\n\t\t\ttransform: translate(200px,0)\n\t\t}\n\t\t100% {\n\t\t\ttransform: translate(0,0)\n\n\t\t}\n\t}\n</style>\n<body>\n\t<div class="container">\n\t\t<div id="ball"></div>\n\t\t<div id="ball2"></div>\n\t</div>\n\t<script>\n\t\tlet ball = document.getElementById(\'ball\')\n\t\tball.classList.add(\'run\')\n\t\tlet ball2 = document.getElementById(\'ball2\')\n\t\tball2.classList.add(\'run2\')\n\t<\/script>\n</body>\n</html>\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("ball分析")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/img/ball.gif",alt:"ball"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("TIP")]),this._v(" "),e("p",[this._v("ball2分析")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"/img/ball2.gif",alt:"ball"}})])}],!1,null,null,null);a.options.__file="性能优化.md";e.default=a.exports}}]);